---
title: 加解密基础知识
layout: post
guid: urn:uuid:02867da0-eb07-435c-a200-49114cafa8f0
tags:
  - 加解密
---

在日常通讯中经常会使用加密和解密技术来保证信息的安全性，随着我们的生活日益依赖互联网，安全通讯亦愈来愈重要。加密算法可以分为：

1.对称加密算法

2.非对称加密算法

3.不可逆加密算法

### 对称加密算法
在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的，即加密和解密使用的同一个密钥。典型的对称加密算法有DES、IDEA和AES。
优点: 算法公开、计算量小、加密速度快及加密效率高；

不足: 加解密使用相同的密钥，无法保证安全性。

### 非对称加密算法
非对称加密算法使用一对公钥和私钥，加密明文时采用公钥加密，解密密文时使用私钥解密。公钥是公开的，自己保留私钥，特别适合分布式系统中的数据加密。广泛应用的非对称加密算法有RSA和DSA。

### 不可逆加密算法
不可逆加密算法在加密过程中不需要使用密钥，直接通过加密算法加密，加密后的数据无法被解密，只有重新输入明文再次加密获取相同的密文，才算真正的解密。通常用于口令加密，典型的不可逆加密算法有MD5和SHS。

在实际的网络通讯过程中，并不是对数据进行加密就能保证安全的。下面以客户和服务器聊天为例: 

> *客户* 对 *服务器*说: 你好, 我是张三

> *服务器* 对 *客户*说: 你好, 我是服务器

由消息是在网络上传输的，有人是可以冒充自己是*服务器*来向客户发送消息的。因此，*客户*接到消息之后，需要进一步验证对方是否为*服务器*。由于只有服务器有私钥，可以通过私钥来验证，通信过程改进如下:

> *客户* 对 *服务器*说: 你好, 我是张三

> *服务器* 对 *客户*说: 你好, 我是服务器

> *客户* 对 *服务器*说: 请证明你是服务器

> *服务器* 对 *客户*说: 张三，我是服务器 + {xxx}(私钥|RSA)  // {}表示RSA加密后的密文, [|]表示用什么密钥和算法进行加密的

为了证明自己是*服务器*，把"张三，我是服务器"这个句号用自己的私钥加密，然后把明文和密文一起加密给*客户*，*客户*收到信息后用公钥进行解密，再与明文进行对比，若一致则说明是*服务器*发过来的。因为私钥只有*服务器*才有，所以其他人无法冒充。

到这里*客户*和*服务器*就可以安全的通信了吗？答案是不能，因为公钥是公开的，所有人都可以查看*服务器*的消息，通信内容无法保密，那么，应该怎么办呢？一般引入对称加密来解决:

> *客户* 对 *服务器*说: 你好, 我是张三

> *服务器* 对 *客户*说: 你好, 我是服务器

> *客户* 对 *服务器*说: 请证明你是服务器

> *服务器* 对 *客户*说: 张三，我是服务器 + {xxx}(私钥|RSA)

> *客户* 对 *服务器*说: {我们后面的通信内容采用对称加密, 这里是*对称加密算法*和*密钥*}[公钥|RSA]

> *服务器* 对 *客户*说: {OK，收到}[密钥|对称加密算法]

上面通信过程中，*客户*在确认了"服务器"的身份后，选择一个*对称加密算法*和*密钥*，发给*服务器*。由于公钥加密的必须有私钥才能解密，故只有*服务器*才能解密。之后的通信内容通过协商的对称加密算法，由于只有双方知道，故可以保证通信内容的安全。

上面的通信是在*客户*持有公钥的情况下进行的，那么，*服务器*是如何将公钥发给*客户*的呢？第一反应可能会想到以下的两个方法:

1.把公钥放到互联网的某一个地方给*客户*下载;

2.每次和*客户*开始通信时, 把公钥发给*客户*。

仔细分析就会发现都存在问题:
对于1方法存在的问题是*客户*无法确定下载地址是不是*服务器*发布的;
对于2方法存在的问题是*黑客*可以自己生成一对公钥和私钥，然后发给*客户*，从而达到欺骗*客户*的效果。

归根结底，问题在于无法确定公钥和私钥对是由谁提供的？这个问题需要*数字证书*来解决。

下一篇介绍*数字证书*如何解决此问题。
